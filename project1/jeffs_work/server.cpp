// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/Job.h"
#include "gen-cpp/Job.cpp"
#include "gen-cpp/Node.h"
#include "gen-cpp/Node.cpp"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TBufferTransports.h>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>

#include <iostream>
#include <sys/types.h>
#include <stdexcept>
#include <sstream>
#include <map>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::project1;

bool isReady = false;
bool isDone = false;

const int NUMBER_OF_NODES = 4;
Node_struct node[NUMBER_OF_NODES];

class JobHandler : virtual public JobIf {
 public:
  JobHandler() : number_map_tasks(0), load_balancing_scheduler(0), reduce_tasks(0){
    // Your initialization goes here
  }

  bool ping(){
    printf("Received Ping\n");
    return true;
  }

  void CountFiles(const std::string& var1) {
    // Your implementation goes here
    unsigned long count = 0;
    printf("Opening: %s\n", var1.c_str());
    struct dirent* direct;
    DIR *pdir = opendir(var1.c_str());
    printf("here\n");
    if(!pdir) {
      printf("Failed to open directory in CountFiles()\n");
      exit(-1);
    }
    while((direct = readdir(pdir)) != NULL) {
        if (!strcmp(direct->d_name, ".") || !strcmp(direct->d_name, "..")) continue;
        ++count;
    }
    closedir(pdir);
    printf("A total of %i tasks in this job.\n", count + 1);
    number_map_tasks = (int) count;
  }

  bool GetStatus() {
    // The nodes poll this function to tell when the server is ready to send them tasks
    if(isReady){
      return true;
    }
    else{
      return false;
    }
    printf("getStatus\n");
  }

  void GetTasks(Node_struct& _return) {
    // Your implementation goes here
    printf("GetTasks\n");
    for(int i = 0; i < NUMBER_OF_NODES; i++){
      if(!node[i].isTaken){
        node[i].isTaken = true;
        _return = node[i];
        printf("Returning Node[%d]\n", i);
        break;
      }
    }
  }

  void PerformJob(std::string& _return, const std::string& input, const int64_t mode) {
    // Your implementation goes here

    printf("PerformJob\n");
    if(load_balancing_scheduler){
      printf("Load Balancing has been selected.\n");
    }
    std::vector <std::string> data_task_files;
    std::string temp_for_pushing = "";
    load_balancing_scheduler = mode;

    int random_num;
    struct dirent *direct;
    DIR *pdir = opendir(input.c_str());
    if(!pdir) {
      printf("Failed to open directory in CountFiles()\n");
    }
    while((direct = readdir(pdir)) != NULL) {
      if (!strcmp(direct->d_name, ".") || !strcmp(direct->d_name, "..")) continue;
      data_task_files.push_back(direct->d_name);
    }
    if(!load_balancing_scheduler) {
      //Assign tasks randomly
      srand (time(NULL));
      for(int i = 0; i < (number_map_tasks+reduce_tasks); i++) {
        random_num = (rand() % 4);
        printf("what: %d\n", rand()%4);
        temp_for_pushing = data_task_files[i];
        node[random_num].fileNames.push_back(temp_for_pushing);
        printf("Task assigned to: Node %d\n", random_num);
      }

    }
    else {
    }
    data_task_files.clear();
    for(int i = 0; i < NUMBER_OF_NODES; i++){
      //printf("Node %i task 1: %s", i, node[i].fileNames.at(0));
      node[i].numberOfFiles = node[i].fileNames.size();
      std::cout << node[i].fileNames.at(0) << "   Size: " << node[i].numberOfFiles<< std::endl;
    }
    isReady = true;
    while(!isDone);
    //////////////////////////////
    _return = "";

  }
private:
  int number_map_tasks = 0;
  int reduce_tasks = 0;
  //vector<string> intermediate_files;
  //std::string final_file;
  int load_balancing_scheduler = 0;
};

int main(int argc, char **argv) {

  //initializating the node_structs
  for(int i = 0; i < NUMBER_OF_NODES; i++){
    node[i].uniqueID = i;
  }

  int port = 9001; //GET FROM CMD LINE????
  shared_ptr<JobHandler> handler(new JobHandler());
  shared_ptr<TProcessor> processor(new JobProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(16);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
  printf("Listening on: %d\n", port);
  server.serve();

  return 0;
}
