// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/Job.h"
#include "gen-cpp/Job.cpp"
#include "gen-cpp/Node.h"
#include "gen-cpp/Node.cpp"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TBufferTransports.h>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>

#include <iostream>
#include <sys/types.h>
#include <stdexcept>
#include <sstream>
#include <map>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <ctime>
#include <chrono>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::project1;

bool isReady = false;
bool isDone = false;

const int NUMBER_OF_NODES = 4;
Node_struct node[NUMBER_OF_NODES];
int g_node_iterator = 0;
class JobHandler : virtual public JobIf {
 public:
  JobHandler() : number_map_tasks(0), load_balancing_scheduler(0), reduce_tasks(0){
    // Your initialization goes here
  }

  bool ping(){
    printf("Received Ping\n");
    return true;
  }

  void CountFiles(const std::string& var1) {
    // Your implementation goes here
    unsigned long count = 0;
    printf("Opening: %s\n", var1.c_str());
    struct dirent* direct;
    DIR *pdir = opendir(var1.c_str());
    if(!pdir) {
      printf("Failed to open directory in CountFiles()\n");
      exit(-1);
    }
    while((direct = readdir(pdir)) != NULL) {
        if (!strcmp(direct->d_name, ".") || !strcmp(direct->d_name, "..")) continue;
        ++count;
    }
    closedir(pdir);
    printf("A total of %i tasks in this job.\n", count + 1);
    if(count == 0) {
      printf("No text files for inputted directory, aborting job");
      exit(1);
    }
    number_map_tasks = (int) count;
  }

  bool GetStatus() {
    // The nodes poll this function to tell when the server is ready to send them tasks
    if(isReady){
      return true;
    }
    else{
      return false;
    }
    printf("getStatus\n");
  }

  void StatusUpdate(const Node_struct& n) {
    // Your implementation goes here
    node[n.uniqueID].isDone = true;
    printf("Node[%d] finished.\n", n.uniqueID);
  }

  bool ReadyForSort() {
    // Your implementation goes here
    bool flag = true;
    for(int i = 0; i < NUMBER_OF_NODES; i++){
      if(!node[i].isDone){
        flag = false;
      }
    }
    if(flag){
      isDone = flag;
    }
    return flag;
    printf("ReadyForSort\n");
  }

  void SendLoad(const Node_struct& n, const double load) {
    // Your implementation goes here
    node[g_node_iterator].load = load;
    g_node_iterator++;
    printf("Node[%d] has load of %f\n", g_node_iterator, node[g_node_iterator].load);
  }

  void GetTasks(Node_struct& _return) {
    // Your implementation goes here
    for(int i = 0; i < NUMBER_OF_NODES; i++){
      if(!node[i].isTaken){
        node[i].isTaken = true;
        _return = node[i];
        printf("Sending to Node[%d]\n", i);
        break;
      }
    }
  }

  void PerformJob(std::string& _return, const std::string& input, const int64_t mode) {
    // Your implementation goes here
    for(int i = 0; i < NUMBER_OF_NODES; i++){
        node[i].cwd = input + "/";
    }

    if(load_balancing_scheduler){
      printf("Load Balancing has been selected.\n");
    }
    std::vector <std::string> data_task_files;
    std::string temp_for_pushing = "";
    load_balancing_scheduler = mode;

    int random_num;
    struct dirent *direct;
    DIR *pdir = opendir(input.c_str());
    if(!pdir) {
      printf("Failed to open directory in CountFiles()\n");
    }
    while((direct = readdir(pdir)) != NULL) {
      if (!strcmp(direct->d_name, ".") || !strcmp(direct->d_name, "..")) continue;
      data_task_files.push_back(direct->d_name);
    }
    if(!load_balancing_scheduler) {
      //Assign tasks randomly
      srand (time(NULL));
      for(int i = 0; i < (number_map_tasks+reduce_tasks); i++) {
        random_num = (rand() % NUMBER_OF_NODES);
        temp_for_pushing = data_task_files[i];
        node[random_num].fileNames.push_back(temp_for_pushing);
        node[random_num].sentiment.push_back(0.0);
        node[random_num].neg_words.push_back(0.0);
        node[random_num].pos_words.push_back(0.0);
        //printf("Task assigned to: Node %d\n", random_num);
      }
    }
    else {
      int task = 0;
      int random_node = 2;
      srand (time(NULL));
      while(task <  number_map_tasks) {
        random_node = (rand() % NUMBER_OF_NODES);
        float random_load = (float) ((float) rand() / (RAND_MAX));
        printf("random_load: %f\n", random_load);
        if(node[random_node].load < random_load) {
          temp_for_pushing = data_task_files[task];
          node[random_node].fileNames.push_back(temp_for_pushing);
          node[random_node].sentiment.push_back(0.0);
          node[random_node].neg_words.push_back(0.0);
          node[random_node].pos_words.push_back(0.0);
          printf("Task assigned to: Node %i\n", random_node);
          task++;
        }
        else{
          std::cout << "Node " << random_node << "\trejected task " << task << "\n";
        }
      }
    }
    data_task_files.clear();
    for(int i = 0; i < NUMBER_OF_NODES; i++){
      //printf("Node %i task 1: %s", i, node[i].fileNames.at(0));
      node[i].numberOfFiles = node[i].fileNames.size();
    }

    //std::clock_t begin = clock();
    auto start = std::chrono::high_resolution_clock::now();
    isReady = true;
    while(!isDone);
    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
    std::cout << "Time taken: " << duration.count() << " microseconds" << std::endl;
    //////////////////////////////
    _return = "final_output.txt";

  }
private:
  int number_map_tasks = 0;
  int reduce_tasks = 0;
  //vector<string> intermediate_files;
  //std::string final_file;
  int load_balancing_scheduler = 0;
};

int main(int argc, char **argv) {

  //initializating the node_structs
  for(int i = 0; i < NUMBER_OF_NODES; i++){
    node[i].uniqueID = i;
    node[i].isTaken = false;
    node[i].load = std::stof(argv[1+i]);
    printf("node %d has %f\n" , i, node[i].load);
  }

  if(node[0].load == 1.0 && node[1].load == 1.0 && node[2].load == 1.0 && node[3].load == 1.0){
    printf("Can't have all loads = 1\n");
    exit(1);
  }
  //int port = std::stoi(argv[1]);
  int port = 9001; //GET FROM CMD LINE????
  shared_ptr<JobHandler> handler(new JobHandler());
  shared_ptr<TProcessor> processor(new JobProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(16);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();

  TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
  printf("Listening on: %d\n", port);
  server.serve();

  return 0;
}
